1、问题定义

管理各队参赛信息

2、问题分析

能够管理各参赛队的基本信息（包含参赛队编号，参赛作品名称，参赛学校，赛事类别，参赛者，指导老师），
赛事类别共11项（参见大赛官网jsjds.blcu.edu.cn）；包括增加、删除、修改参赛队伍的信息。
从team.txt中读取参赛队伍的基本信息，实现基于二叉排序树的查找。
根据提示输入参赛队编号，若查找成功，输出该赛事类别对应的基本信息（参赛作品名称、参赛学校、赛事类别、参赛者和指导老师信息），
同时，输出查找成功时的平均查找长度ASL；否则，输出“查找失败！”。

3、概要设计

数据结构设计：

参赛队伍的数据结构：结构体--Team 用于存储参赛队的基本信息（包含参赛队编号，参赛作品名称，参赛学校，赛事类别，参赛者，指导老师）
struct Team         //参赛队伍
{
	int id_team;        //队伍编号
	string name_creation; //作品名称
	string school;      //参赛学校
	string category;   //参赛类别
	string competitor; //参赛者
	string tutor;      //指导老师
  	Team* left;        //左指针
	Team* right;       //右指针
};

所有的参赛队伍通过一个二叉排序树存储起来
Team *root;
指向根节点。

从txt录入的信息存入二维容器：
vector<vector<string>>data;

定义一个System类
class System {          //赛事系统

通过创建一个Manage_information的单例对象为它的成员实现信息管理功能的使用
private:
        	Manage_informatiom manager;
          
使用init()方法实现从txt读入数据将其用二叉排序树存储起来
void init();           //读取文件存入容器

使用bitree（）实现二叉树的建立
void bitree();         //建立排序二叉树

使用select_function()实现各个功能的选择
void select_funtion();


定义一个信息管理类Manage_information ,
class Manage_informatiom 

定义一系列功能函数

 //比较编号大小
bool cmp(string x1, string x2); 
//基于id的查找
Team* search_id(Team *r,string id);  
//基于学校的查找
void search_school(Team* r, string school);
//删除一个队伍
void del(Team* r, string id); 
//插入一个队伍
Team* add(Team *root,Team *s);  
//修改一个队伍的信息
void change(Team *root,string id);  
//展示一个队伍的信息
void show_information(Team* r, string id); 
//中序展示二叉树所有队伍信息
void show_allteam(Team* r);     
 //总查找长度
int SL(Team* r, int len);   
//计算队伍总数
int num_team(Team* r);	
//二叉排序树中序后继代替
void nextDel(Team *p);
//将更新后的信息写回txt
void write(Team *root);
//递归归并排序赛事类别
void MergeSort(Team* p[], Team* q[],int left,int right);
//相邻两个归并段合成一个
void Merge(Team* p[], Team* q[],int s,int m,int t);                              



